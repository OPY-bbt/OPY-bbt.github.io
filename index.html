<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="大前端">
<meta name="keywords" content="React,Flutter">
<meta property="og:type" content="website">
<meta property="og:title" content="前路漫漫 唯风作伴">
<meta property="og:url" content="https://github.com/OPY-bbt/index.html">
<meta property="og:site_name" content="前路漫漫 唯风作伴">
<meta property="og:description" content="大前端">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="前路漫漫 唯风作伴">
<meta name="twitter:description" content="大前端">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://github.com/OPY-bbt/"/>





  <title>前路漫漫 唯风作伴</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">前路漫漫 唯风作伴</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">脚踏大地 仰望星空</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/OPY-bbt/2021/05/09/光栅图形学-扫描转换算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="山石岩">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/16717283?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前路漫漫 唯风作伴">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/09/光栅图形学-扫描转换算法/" itemprop="url">光栅图形学-扫描转换算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-05-09T22:37:05+08:00">
                2021-05-09
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2021/05/09/光栅图形学-扫描转换算法/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2021/05/09/光栅图形学-扫描转换算法/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文介绍了直线段、圆弧、多边形扫描转换算法。使用 Javascript 实现多边形扫描算法。</p>
<h2 id="直线段的的扫描转换算法"><a href="#直线段的的扫描转换算法" class="headerlink" title="直线段的的扫描转换算法"></a>直线段的的扫描转换算法</h2><p>记得在上大学的时候，刚开始学单片机。老爸让我在液晶屏上实现画出一次方程直线的功能，当时捣鼓了一上午才搞定一条歪歪扭扭的线。这几年时间过去，又在看如何画直线，果然是轮回。<br>主要有三种方式 数值微分(DDA)法、中点画线法、布雷森汉姆（Bresenham）算法</p>
<h4 id="DDA算法"><a href="#DDA算法" class="headerlink" title="DDA算法"></a>DDA算法</h4><p>求出直线斜率 k。当 |k| &lt;= 1 时，x每递增1时，y递增k。当 |k| &gt; 1 时，y 每增加1，x 增加 1 / k。这样才能保证点是连续的。<br>在这个算法中，y 和 k 必须用浮点数表示，而且每一步都要对 y 进行四舍五入取整，效率不高。因为是对每个像素进行处理，所以在图形学中效率非常重要，后面也会有对浮点数以及乘除的优化。<br>当 |k| &lt;= 1 时，伪代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DDALine</span><span class="params">(<span class="keyword">int</span> x0, <span class="keyword">int</span> y0, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  <span class="keyword">float</span> dx, dy, y, k,</span><br><span class="line">  dx = x1 - x0,</span><br><span class="line">  dy = y1 - y0,</span><br><span class="line">  k = dy / dx,</span><br><span class="line">  y = y0;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (x = x0; x &lt;= x1; x++) &#123;</span><br><span class="line">    drawpixel(x, <span class="keyword">int</span>(y + <span class="number">0.5</span>), color);</span><br><span class="line">    y = y + k;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="中点画线法"><a href="#中点画线法" class="headerlink" title="中点画线法"></a>中点画线法</h4><p>通过观察下图可以看到，假如当前点为 P，则下一个像素点有两种情况，P1和P2。<br>M点为P1，P2中点，Q点为理想直线上的点。当 M 在 Q 下方，P2 应为下一个像素点，当 M 在 Q 上方，P1 应为下一个像素点。所以可以通过比较F(Mx, My) 和 0 的大小，可以确定下个像素点位置。</p>
<p><code>d = F(M) = F(Px + 1, Py + 0.5) = a(Px + 1) + b(Py + 0.5) + c;</code></p>
<p><img src="../images/computer_graphic_mid.png" alt="mid"></p>
<p>对于过 （x0, y0）(x1, y1) 两点的直线L来说，采用方程 F(x, y) = ax+ by + c = 0表示。其中 a = y0 - y1, b = x1 - x0, c = x0y1 - x1y0;</p>
<p>利用此方程可以画出直线，但是这种方式需要进行 4 个加法和两个乘法。事实上，d 是 Px, Py的线性函数，所以可以使用增量计算的方法优化。<br>若 d &gt;= 0，则取正右方像素 P1,那么判断下一个像素位置就是<code>d1 = F(Px + 2, Py + 0.5) = d + a;</code>,增量为 a.<br>若 d &lt; 0，则取右上方像素P2，那么判断下一个像素位置就是 <code>d1 = F(Px + 2, Py + 1.5) = d + a + b;</code>增量为 a + b<br>设从点（x0， y0）开始画线，d的初值为<code>d0 = F(x0 + 1, y0 + 0.5) = F(x0， y0) + a + 0.5b = a + 0.5b</code><br>由于使用的只是 d 的符号，而 d 的增量都是整数，只有初始值包含小数，所以用 2d 代替 d 来摆脱浮点运算。优化过后的伪代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> Midpoint <span class="title">Line</span><span class="params">(<span class="keyword">int</span> x0, <span class="keyword">int</span> y0, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a, b, d1, d2, d, x, y;</span><br><span class="line">  a = y0 - y1, b = x1 - x0, d = <span class="number">2</span> * a + b;</span><br><span class="line">  d1 = <span class="number">2</span> * a, d2 = <span class="number">2</span> * (a + b);</span><br><span class="line">  x = x0, y = y0;</span><br><span class="line">  drawpixel(x, y, color;</span><br><span class="line">  <span class="keyword">while</span>(x &lt; x1) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (d &lt; <span class="number">0</span>)</span><br><span class="line">      &#123; x++, y++, d += d2;&#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      &#123;x++, d += d1;&#125;</span><br><span class="line">    drawpixel(x, y, color);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Bresenham"><a href="#Bresenham" class="headerlink" title="Bresenham"></a>Bresenham</h4><p>类似于中点画线法，通过偏移量d与0.5的比较来确定像素点所在的位置，其中d1 = d0 + k;</p>
<p><img src="../images/computer_graphic_bresenham.png" alt="bresenham"></p>
<h2 id="圆弧的的扫描转换算法"><a href="#圆弧的的扫描转换算法" class="headerlink" title="圆弧的的扫描转换算法"></a>圆弧的的扫描转换算法</h2><p>圆有四条对称轴，所以已知圆弧上一点（x, y），可以得到其关于4条对称轴的其他 7 个点，这种性质被称为八对称性。因此，只要扫描转换 1/8 圆弧，就可以用八对称性求出整个圆的像素集.具体算法也是类似于中点画线法，只不过函数方程变为圆。</p>
<p><img src="../images/computer_graphic_circle.png" alt="circle"></p>
<h2 id="多边形的的扫描转换算法"><a href="#多边形的的扫描转换算法" class="headerlink" title="多边形的的扫描转换算法"></a>多边形的的扫描转换算法</h2><p>在计算机图形学中，多边形有顶点和点阵两种表现方式。<br>顶点表示直观，几何意义强，占内存少，易于进行几何变换。但不利于着色。<br>点阵表示丢失了许多几何信息，但便于帧缓冲器表示图形。光栅图形学的本质问题是把多边形的顶点表示转换为点阵表示，这种转换被称为多边形的扫描转换。其中有两种方法，扫描线算法和边界标志算法，下方会用 javascript 在 canvas 中实现扫描线算法。</p>
<h4 id="扫描线算法"><a href="#扫描线算法" class="headerlink" title="扫描线算法"></a>扫描线算法</h4><p>通过计算扫描线与多边形的相交区间，再用要求的颜色显示这区间的像素，以完成填充工作。区间的端点通过计算扫描线与多边形的边界线交点获得。<br>对于一条扫描线，主要分为下面四个步骤：</p>
<ol>
<li>求交。计算扫描线与多边形各边的交点</li>
<li>排序。把所有交点按 x 值的递增顺序排序</li>
<li>配对。将1和2，3和4等等配对</li>
<li>填色。相交区间内的像素置为多边形的颜色</li>
</ol>
<p><img src="../images/computer_graphic_poly.png" alt="circle"></p>
<p>由于反复求交运算效率低下，为了优化这个问题，将引入两个概念AET和NET。<br>将与当前扫描线相交的边称为活性边(AET)。如果某边的较低端点为ymin，则改边就放在扫描线 ymin 的新边表(NET)中。边在 AET 和 NET 中存储使用单链表的形式。每个节点包含三个信息，1、存当前扫描线与边的交点坐标x值，2、从当前扫描线到下一条扫描线间x的增量 dx；3、存该边所交的最高扫描线号ymax。<br>有了NET之后，就可以通过 NET 来维护 AET，如果当前扫描线在 NET中 有值时，就加入到 AET中，每次扫描线加一，就在原来x的基础上增加dx。当扫描线号大于 ymax时，将其从AET中删除。伪代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">polyfill</span><span class="params">(polygon, color)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> color</span></span><br><span class="line">多边形 polygon</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (各条扫描线 i) &#123;</span><br><span class="line">    初始化新边表头指针 NET[i]</span><br><span class="line">    把 ymin = i 的边放进 NET[i]</span><br><span class="line">  &#125;</span><br><span class="line">  y = 最低扫描线号</span><br><span class="line">  初始化活性边表为空</span><br><span class="line">  <span class="keyword">for</span> (各条扫描线i) &#123;</span><br><span class="line">    把 NET[i] 中的边结点用插入排序法插入 AET, 使之按 x 坐标递增顺序排列</span><br><span class="line">    若允许多边形的边自相交，则用冒泡排序法对 AET 重新排序</span><br><span class="line">    遍历 AET， 把配对交点区间（左闭右开）上的像素（x，y），用 drawpixel(x, y, color) 改写像素颜色值</span><br><span class="line">    遍历 AET，把 ymax = i 的结点从 AET 中删除，并把 ymax &gt; i 结点的 x 值递增 dx;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 javascript 实现此算法:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">width</span>=<span class="string">"400"</span> <span class="attr">height</span>=<span class="string">"400"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> WIDTH = <span class="number">400</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> HEIGHT = <span class="number">400</span>;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 输入三角形中的三个顶点</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> POINTS = [[<span class="number">200</span>, <span class="number">50</span>], [<span class="number">150</span>, <span class="number">300</span>], [<span class="number">300</span>, <span class="number">350</span>]];</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="undefined"> </span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> AET = []; <span class="comment">// 活性边</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> NET = &#123;&#125;; <span class="comment">// 新边表，这里为了方便使用数组</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> ctx = <span class="built_in">document</span>.body.querySelector(<span class="string">'canvas'</span>).getContext(<span class="string">'2d'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 将 canvas 中的坐标系与笛卡尔坐标系保持一致，方便绘制</span></span></span><br><span class="line"><span class="undefined">    ctx.translate(0, HEIGHT);</span></span><br><span class="line"><span class="undefined">    ctx.scale(1, -1);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    POINTS.forEach(<span class="function"><span class="params">p</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      drawPixel(p[<span class="number">0</span>], p[<span class="number">1</span>], <span class="string">'#F00'</span>, <span class="number">3</span>);</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 初始化 NET</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 如果某边的较低端点为ymin,则该边就放在扫描线ymin的新边表中。</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; POINTS.length; i++) &#123;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 由 point 和 next_point 组成的边</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> point = POINTS[i];</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> j = i === POINTS.length - <span class="number">1</span> ? <span class="number">0</span> : i + <span class="number">1</span>;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> next_point = POINTS[j];</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> minY_point = point[<span class="number">1</span>] &lt;= next_point[<span class="number">1</span>] ? point : next_point;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> maxY_point = point[<span class="number">1</span>] &lt;= next_point[<span class="number">1</span>] ? next_point : point;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> newNode = &#123;</span></span><br><span class="line"><span class="undefined">        x: minY_point[0],</span></span><br><span class="line"><span class="javascript">        <span class="comment">// <span class="doctag">TODO:</span> 没有考虑水平的情况</span></span></span><br><span class="line"><span class="undefined">        dx: (maxY_point[0] - minY_point[0]) / (maxY_point[1] - minY_point[1]),</span></span><br><span class="line"><span class="undefined">        ymax: maxY_point[1],</span></span><br><span class="line"><span class="javascript">        next: <span class="literal">null</span>,</span></span><br><span class="line"><span class="undefined">        points: [i, j],</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> ymin = minY_point[<span class="number">1</span>];</span></span><br><span class="line"><span class="undefined">      </span></span><br><span class="line"><span class="javascript">      <span class="comment">// 将点存在新边表中，如果新边表中已经存在值则放在链表尾部</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (NET[ymin]) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> current = NET[ymin];</span></span><br><span class="line"><span class="javascript">        <span class="keyword">while</span> (current.next) &#123;</span></span><br><span class="line"><span class="undefined">          current = current.next;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">        current.next = newNode;</span></span><br><span class="line"><span class="javascript">      &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="undefined">        NET[ymin] = newNode;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'NET'</span>, NET);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 遍历所有扫描边，绘制图形</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; HEIGHT; i++) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 假如新边表有值，将节点插入 AET 中</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (NET[i]) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> current = NET[i];</span></span><br><span class="line"><span class="javascript">        <span class="keyword">while</span> (current) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="comment">// NET 插入排序法 进 AET</span></span></span><br><span class="line"><span class="javascript">          <span class="keyword">let</span> j = <span class="number">0</span></span></span><br><span class="line"><span class="javascript">          <span class="keyword">for</span> (; j &lt; AET.length; j++) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (AET[j].x &gt; current.x) &#123;</span></span><br><span class="line"><span class="javascript">              <span class="keyword">break</span>;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">          &#125;</span></span><br><span class="line"><span class="undefined">          AET.splice(j, 0, current);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">          current = current.next;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 遍历 AET 表，如果扫描边等于节点 ymax 值，</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 则说明已经超出此线段范围，从 AET 中删除。</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 否则，x 值递增 dx</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; AET.length; j++) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> node = AET[j];</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (node.ymax === i) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="comment">// 删除此节点</span></span></span><br><span class="line"><span class="undefined">          AET.splice(j, 1);</span></span><br><span class="line"><span class="undefined">          j--;</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.ymax &gt;= i) &#123;</span></span><br><span class="line"><span class="undefined">          node.x = node.x + node.dx</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">  </span></span><br><span class="line"><span class="javascript">      <span class="comment">// 将 AET 中的节点，两两配对，绘制两点之间的线段</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; AET.length; j += <span class="number">2</span>) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (AET[j] &amp;&amp; AET[j + <span class="number">1</span>]) &#123;</span></span><br><span class="line"><span class="undefined">          drawPixels(AET[j].x, AET[j + 1].x, i);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'AET'</span>, AET);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">drawPixels</span>(<span class="params">x1, x2, y</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">for</span> (<span class="keyword">let</span> i = x1; i &lt; x2; i++) &#123;</span></span><br><span class="line"><span class="undefined">        drawPixel(i, y);</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">drawPixel</span>(<span class="params">x, y, color = <span class="string">'#000'</span>, size = <span class="number">1</span></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">      ctx.fillStyle = color;</span></span><br><span class="line"><span class="javascript">      ctx.fillRect(<span class="built_in">Math</span>.round(x), <span class="built_in">Math</span>.round(y), size, size);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="../images/computer_graphic_effect.png" alt="circle"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/OPY-bbt/2021/04/15/Chrome浏览器工作原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="山石岩">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/16717283?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前路漫漫 唯风作伴">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/15/Chrome浏览器工作原理/" itemprop="url">Chrome 浏览器原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-15T22:37:05+08:00">
                2021-04-15
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2021/04/15/Chrome浏览器工作原理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2021/04/15/Chrome浏览器工作原理/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Part-1-浏览器架构"><a href="#Part-1-浏览器架构" class="headerlink" title="Part 1 浏览器架构"></a>Part 1 浏览器架构</h3><p>CPU, GPU, Memory, 多进程架构, 通过 IPC(Inter Process Communication)通信。包含的几个进程及内容:</p>
<ul>
<li>Browser process: 地址栏，书签，前进，后退，网络请求和文件</li>
<li>Render process: 控制所有 tab 中显示的内容</li>
<li>Plugin: 例如 flash</li>
<li>GPU: 处理 GPU 任务</li>
</ul>
<p>通过 Chrome 右上角-更多工具-任务管理器, 可以查看进程, 一般情况下，每个 Tab 页都是一个 render process，使得页面之间互不影响，并且更加安全。如果多个tab页，但网站之间是同域的，还是会共享一个 render process。</p>
<p>Site Isolation 技术实现了即使是跨域的 iframe，也会使用不同的 render process。这意味着一个 Tab 页，可能对应多个 render process。此技术是里程碑式的，没有想象的这么简单，比如 Ctrl + F 必须在多个Render process中搜索。</p>
<h3 id="Part-2-在导航期间发生了什么"><a href="#Part-2-在导航期间发生了什么" class="headerlink" title="Part 2 在导航期间发生了什么"></a>Part 2 在导航期间发生了什么</h3><p>导航从 Browser process开始，Browser process 中包含了 UI thread（绘制按钮和搜索框）、Network thread（请求数据）、Storage thread（文件）。</p>
<ul>
<li>（处理输入）当用户在地址栏输入文字时，UI thread 会解析字符串，判断是搜索文字还是URL地址。</li>
<li>（开始导航）当用户点击 Enter 按键，UI thread 会初始化网络请求获取内容。Network thread 会进行 DNS查询、建立 TLS连接。</li>
<li>（读响应数据）当获取到 Response body时，Network thread 会通过 Content-Type 选择合适的处理方式。如果请求是HTML file，会将数据传递给 Renderer process，如果是 zip 或者其他下载文件，会传递给下载管理器。</li>
<li>（找到 renderer process）如果请求返回数据通过了安全检查，Network thread 会通知 UI thread，UI thread 会使用 Renderer process 渲染页面。</li>
<li>（提交 navigation）数据会通过IPC从 Browser process 发到 Renderer process。如果 navigation 已经完成，Renderer process 会通知 Browser [Page loaded], 地址栏旁边的spinner将会消失。提交导航后，Renderer process 将会继续加载资源和渲染页面，具体细节，会在后面说到。</li>
</ul>
<h3 id="Part-3-渲染器进程"><a href="#Part-3-渲染器进程" class="headerlink" title="Part 3 渲染器进程"></a>Part 3 渲染器进程</h3><p>渲染器进程处理tab页中所有的事情。main thread处理大部分代码，一些web worker 和 service worker相关的代码会交给 worker thread。compositor thread 和 raster thread 负责渲染页面更有效率和流畅。</p>
<p>renderer process 核心工作是将 HTML，CSS， JS 转变成可交互页面。</p>
<p>main thread 解析HTML文件为 DOM 结构，HTML解析器遇到 script 标签会停止解析，直到加载，解析，执行 js 代码完成之后。因为 js 可能会导致 DOM 结构改变。</p>
<p>得到DOM之后，main thread 解析 CSS 得到每个 DOM Node 的 computed style。</p>
<p>得到 computed style 之后，准备生成 layout tree，获取元素的几何结构，例如元素 x，y坐标，盒尺寸等。</p>
<p>然后是 paint 步骤，决定绘制顺序，比如 z-index。结果是生成绘制指令不是真的绘制。main thread 会遍历 layout tree 生成 paint records(类似 “background first, then text, then rectangle”.)。</p>
<p>得到 paint 指令之后，将这些信息转变为屏幕上的像素被称为栅格化(rasterizing)。在 Chrome 早期的时候，初始化时栅格化 viewport 中的内容，当用户滚动之后，在对新内容进行栅格化。在后期版本中，又增加了一个 合成(compositing)步骤。</p>
<p>Compositing 会将页面分为不同的层，并且对每一层进行栅格化。当有滚动、动画发生时，仅通过合成来获得新的帧。为了判断元素应该被放在哪一层里，主线程会通过遍历 layout tree 去创建 layer tree（可以通过will-change生成新的layer）。</p>
<p>一旦 layer tree 和 paint order 准备就绪，主线程会将信息提交给 compositor thread。然后在栅格化每一层。layer 可能会是整个页面大小，所以 compositor thread 会把layer切分成瓦片(tile)。然后栅格进程对tile进行栅格化，并将结果保存在 GPU中。</p>
<p>当 tile 被栅格化之后，compositor thread 收集 tile 信息，draw quads 和 compositor frame（draw quads 集合）。然后合成帧被提交给浏览器进程。然后被发送给GPU。合成的好处就是不需要主线程参与，就可以生成合成帧，保证动画流畅。</p>
<h3 id="Part-4-处理用户事件输入"><a href="#Part-4-处理用户事件输入" class="headerlink" title="Part 4 处理用户事件输入"></a>Part 4 处理用户事件输入</h3><p>当用户touch事件发生时，Browser process 首先接收到，然后发送事件类型和坐标给 Renderer process 中合成线程，然后通知 main thread，其查找事件目标元素和运行事件监听器。</p>
<p>合成线程会将页面中带有事件监听器的区域标记为 Non-Fast Scrollable Region，如果事件在这个区域发生，合成线程会发送给 main thread。如果这个区域没有时间发生，则不需要等待 main thread。所以，大量的事件代理，也会影响性能，因为这样会导致标记区域变大。为了防止这种事情发生，通过设置 passive：true(表示永远不会调用 preventDefault)，可以告诉浏览器虽然需要主线程监听，但是合成线程可以继续生成合成帧，不必等待，可以使得滚动更加顺滑。</p>
<p>main thread 通过 x，y 坐标和查找 paint records 来确定事件目标</p>
<p>屏幕一般刷新率为60hz，而move事件一般为 60-120hz，所以 Chrome会合并持续事件（wheel，mousewheel，mousemove，touchmove）到下一个requestAnimationFrame 之前触发，避免无效的事件触发。但是，如果你需要精确的用户事件坐标，如果绘图软件等，那么就需要使用 getCoalescedEvents。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'pointermove'</span>, event =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> events = event.getCoalescedEvents();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> event <span class="keyword">of</span> events) &#123;</span><br><span class="line">        <span class="keyword">const</span> x = event.pageX;</span><br><span class="line">        <span class="keyword">const</span> y = event.pageY;</span><br><span class="line">        <span class="comment">// draw a line using x and y coordinates.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/OPY-bbt/2021/04/11/最小生成树MST的两种算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="山石岩">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/16717283?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前路漫漫 唯风作伴">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/11/最小生成树MST的两种算法/" itemprop="url">计算最小生成树MST的两种算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-11T22:37:05+08:00">
                2021-04-11
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2021/04/11/最小生成树MST的两种算法/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2021/04/11/最小生成树MST的两种算法/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>MST(minimum-spanning-tree)算法，用于计算在加权无向连通图中，生成最小权重的树。</p>
<p><img src="../images/mit.png" alt="MIT"></p>
<p>使用邻接矩阵表示上图：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> graph = [</span><br><span class="line">  [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>],</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>主要有两种算法：</p>
<ul>
<li>Prim（普里姆） 算法</li>
<li>Kruskal（克鲁斯卡尔） 算法</li>
</ul>
<h3 id="Prim（普里姆）算法：每次从未遍历的节点中选择最小权重点连线"><a href="#Prim（普里姆）算法：每次从未遍历的节点中选择最小权重点连线" class="headerlink" title="Prim（普里姆）算法：每次从未遍历的节点中选择最小权重点连线"></a>Prim（普里姆）算法：每次从未遍历的节点中选择最小权重点连线</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prim</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> parent = [],</span><br><span class="line">    key = [],</span><br><span class="line">    visited = [],</span><br><span class="line">    length = graph.length,</span><br><span class="line">    i;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把所有顶点 key 设置为无限大，未访问</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    key[i] = <span class="built_in">Number</span>.MAX_SAFE_INTEGER;</span><br><span class="line">    visited[i] = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 选择第一个 key 作为第一个顶点</span></span><br><span class="line">  key[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 第一个顶点为 MST 根结点，所以 parent 为 -1</span></span><br><span class="line">  parent[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对所有顶点求 MST</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 从未处理集合中选出最小的key</span></span><br><span class="line">    <span class="keyword">var</span> u = minKey(key, visited);</span><br><span class="line">    <span class="comment">// 设置未true，避免重复计算</span></span><br><span class="line">    visited[u] = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历所有点，如果得出更小的权重，则在 parent 中 保存路径</span></span><br><span class="line">    <span class="comment">// 并且更新顶点权重值 key</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> v = <span class="number">0</span>; v &lt; length; v++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (graph[u][v] &amp;&amp;</span><br><span class="line">          visited[v] === <span class="literal">false</span> &amp;&amp;</span><br><span class="line">          graph[u][v] &lt; key[v]) &#123;</span><br><span class="line">        parent[v] = u;</span><br><span class="line">        key[v] = graph[u][v];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">minKey</span>(<span class="params">key, visited</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> min = <span class="built_in">Number</span>.MAX_SAFE_INTEGER,</span><br><span class="line">    minIndex = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> v = <span class="number">0</span>; v &lt; key.length; v++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (visited[v] == <span class="literal">false</span> &amp;&amp; key[v] &lt;= min) &#123;</span><br><span class="line">      min = key[v];</span><br><span class="line">      minIndex = v;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> minIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Kruskal（克鲁斯卡尔）-算法-每次从未遍历的边中选择最小权重的边"><a href="#Kruskal（克鲁斯卡尔）-算法-每次从未遍历的边中选择最小权重的边" class="headerlink" title="Kruskal（克鲁斯卡尔） 算法: 每次从未遍历的边中选择最小权重的边"></a>Kruskal（克鲁斯卡尔） 算法: 每次从未遍历的边中选择最小权重的边</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">kruskal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> INF = <span class="built_in">Number</span>.MAX_SAFE_INTEGER;</span><br><span class="line">  <span class="keyword">var</span> length = graph.length;</span><br><span class="line">  <span class="keyword">var</span> parent = [];</span><br><span class="line">  <span class="keyword">var</span> ne = <span class="number">0</span>,</span><br><span class="line">    a,</span><br><span class="line">    b,</span><br><span class="line">    u,</span><br><span class="line">    v,</span><br><span class="line">    i,</span><br><span class="line">    j,</span><br><span class="line">    min;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 拷贝 graph 到 cost 中，方便修改和保留原始值</span></span><br><span class="line">  <span class="keyword">var</span> cost = initializeCost(graph);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当 MST 的边数小于顶点总数 - 1 时</span></span><br><span class="line">  <span class="keyword">while</span> (ne &lt; length - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 选出权重最小边</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, min = INF; i &lt; length; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cost[i][j] &lt; min) &#123;</span><br><span class="line">          min = cost[i][j];</span><br><span class="line">          u = i;</span><br><span class="line">          v = j;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分别找出 u，v 的祖先节点，看是否为同一节点，如果是，则跳过</span></span><br><span class="line">    <span class="comment">// 避免环路</span></span><br><span class="line">    <span class="keyword">if</span> (union(find(u, parent), find(v, parent), parent)) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"edge"</span>, u, v, graph[u][v]);</span><br><span class="line">      ne++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 避免重复计算</span></span><br><span class="line">    cost[u][v] = cost[v][u] = INF;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> find = <span class="function"><span class="keyword">function</span> (<span class="params">i, parent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (parent[i] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    i = parent[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> union = <span class="function"><span class="keyword">function</span> (<span class="params">i, j, parent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i != j) &#123;</span><br><span class="line">    parent[j] = i;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> initializeCost = <span class="function"><span class="keyword">function</span>(<span class="params">graph</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cost = [];</span><br><span class="line">  <span class="keyword">const</span> &#123; length &#125; = graph;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    cost[i] = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (graph[i][j] === <span class="number">0</span>) &#123;</span><br><span class="line">        cost[i][j] = INF;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cost[i][j] = graph[i][j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cost;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/OPY-bbt/2021/03/14/Core-Web-Vitals/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="山石岩">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/16717283?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前路漫漫 唯风作伴">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/14/Core-Web-Vitals/" itemprop="url">Core Web Vitals</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-14T22:37:05+08:00">
                2021-03-14
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2021/03/14/Core-Web-Vitals/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2021/03/14/Core-Web-Vitals/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Google总结了健康网络的三个指标，旨在提高用户体验：</p>
<ul>
<li>Largest Contentful Paint (LCP): 最大内容绘制</li>
<li>First Input Delay (FID): 首次输入延迟</li>
<li>Cumulative Layout Shift (CLS): 累积布局转移<br>指标其实分别对应网站健康度的三个方面：加载、交互性、页面稳定性。<br>本文对这篇文章做总结，包含三个部分：指标定义，如何度量，如何优化。</li>
</ul>
<h3 id="LCP"><a href="#LCP" class="headerlink" title="LCP"></a>LCP</h3><p><code>是衡量页面加载性能的核心指标，表示视口中最大的文字或者图片块渲染的时间。</code></p>
<p>largest contentful elements 有以下几类：</p>
<ul>
<li>img 标签</li>
<li>SVG 中的 image</li>
<li>设置封面的 video</li>
<li>通过 background：url()加载背景的元素</li>
<li>包含了文本节点的块级元素</li>
</ul>
<p>需要注意的是，增加元素，删除元素会可能会改变 largest contentful element。<br>并且，加载没有完成的图片，字体没有加载完成的文字，也不能被认为是 contentful element，只有当加载完成后才是。<br>如果用户与页面有交互事件的发生（点击，滑动），浏览器就不会发布新的largest- contentful-paint 事件</p>
<h4 id="测量"><a href="#测量" class="headerlink" title="测量"></a>测量</h4><p>使用 PerformanceObserver API测量</p>
<p>new PerformanceObserver((entryList) =&gt; {})<br>.observe({type: ‘largest-contentful-paint’});<br>一般来说最后一个entry的startTime就是 largest-contentful-paint 时间,但也有例外的情况，主要是和background tab 相关。</p>
<p>Google已经提供了测量工具：<a href="https://github.com/GoogleChrome/web-vitals">https://github.com/GoogleChrome/web-vitals</a></p>
<p>也存在最大的元素并不是最重要的情况，这时候就需要自定义Timing工具 <a href="https://wicg.github.io/element-timing/" target="_blank" rel="noopener">https://wicg.github.io/element-timing/</a></p>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>导致LCP很糟糕的原因主要有以下几种：</p>
<ul>
<li>服务器响应慢(没错，甩锅给后端是每个前端必备的能力)</li>
<li>JS 或者 CSS 阻塞</li>
<li>资源加载慢</li>
<li>客户端渲染慢</li>
</ul>
<p>对与服务器响应慢的情况，首先使用 window.performance.timing 来测量 TTFB，看是否因为服务器的问题。然后就是服务器优化的问题了，不展开。CDN，Cache等。</p>
<p>新增知识点get: 通过 <code>&lt;link rel=&quot;preconnect&quot; href=&quot;https://example.com&quot; /&gt;</code> 可以提前与服务器建立连接。或者 dns-prefetch 提前获得IP地址（不过这个因为缓存的原因，只有第一次请求的时候会有提高）</p>
<p>对于CSS阻塞渲染的情况，除了常见的减小体积，内联重要的css，还有一个是异步，用一个link标签就可以搞定：<br><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;/path/to/my.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;; this.onload=null;&quot;&gt;</code></p>
<p>在页面初始化的时候，仅加载需要用到的CSS样式，再异步请求剩余的CSS内容是比较好的处理方法，而且有已经有webpack插件来处理 <a href="https://github.com/GoogleChromeLabs/critters">https://github.com/GoogleChromeLabs/critters</a></p>
<h3 id="FID"><a href="#FID" class="headerlink" title="FID"></a>FID</h3><p><code>用户第一次与页面交互到执行监听事件所需的时间。</code></p>
<p>当主线程繁忙（解析或者执行JS文件的时候），浏览器不会立即响应用户操作。</p>
<h4 id="测量："><a href="#测量：" class="headerlink" title="测量："></a>测量：</h4><p>因为FID的测量需要用户点击，所以在实验环境中使用Total Blocking Time（TBT）</p>
<h4 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h4><ul>
<li>超过50ms的任务被认为是长任务。分割长任务为多个小的，异步执行任务是有效的方式。</li>
<li>使用 webworker</li>
</ul>
<h3 id="CLS"><a href="#CLS" class="headerlink" title="CLS"></a>CLS</h3><p><code>元素改变位置的得分总和</code></p>
<p>分数是影响分数和距离分数的乘积</p>
<p>layout shift score = impact fraction * distance fraction<br>impact fraction 代表前后两帧中，不稳定元素占视口的比例</p>
<p>distance fraction 代表所有不稳定元素中移动距离占视口的最大比例</p>
<h4 id="优化：-1"><a href="#优化：-1" class="headerlink" title="优化："></a>优化：</h4><ul>
<li>图片和视频需要加上尺寸属性</li>
<li>除非用户交互，否则不要在已有的元素上插入新的元素</li>
<li>使用 transform 动画</li>
</ul>
<h3 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h3><p><a href="https://web.dev/learn-web-vitals/" target="_blank" rel="noopener">https://web.dev/learn-web-vitals/</a><br><a href="https://web.dev/optimize-lcp/" target="_blank" rel="noopener">https://web.dev/optimize-lcp/</a><br><a href="https://wicg.github.io/element-timing/" target="_blank" rel="noopener">https://wicg.github.io/element-timing/</a><br><a href="https://github.com/filamentgroup/loadCSS/blob/master/README.md">https://github.com/filamentgroup/loadCSS/blob/master/README.md</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/OPY-bbt/2021/02/01/从测试看react源码-schedulerBrowser/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="山石岩">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/16717283?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前路漫漫 唯风作伴">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/01/从测试看react源码-schedulerBrowser/" itemprop="url">从测试看react源码_schedulerBrowser</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-02-01T22:00:00+08:00">
                2021-02-01
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2021/02/01/从测试看react源码-schedulerBrowser/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2021/02/01/从测试看react源码-schedulerBrowser/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>主要测试 Scheduler 在浏览器中的运行。主要利用 MessageChannel API 进行异步执行 Task</code></p>
<h3 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h3><p>模拟浏览器 MessageChannel API，Mock了 port1 用于异步 onmessage，port2 用于 postmessage<br>在 port1的 onmessage 赋值了 performWorkUntilDeadline，此函数执行work直至当前 时间切片结束，默认时间切片时间为5ms，时间切片结束，将会把控制权交还给主线程，用于响应用户事件等。</p>
<h5 id="1-task-that-finishes-before-deadline"><a href="#1-task-that-finishes-before-deadline" class="headerlink" title="1. task that finishes before deadline"></a>1. task that finishes before deadline</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'task that finishes before deadline'</span>, () =&gt; &#123;</span><br><span class="line">  scheduleCallback(NormalPriority, () =&gt; &#123;</span><br><span class="line">    runtime.log(<span class="string">'Task'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  runtime.assertLog([<span class="string">'Post Message'</span>]);</span><br><span class="line">  runtime.fireMessageEvent();</span><br><span class="line">  runtime.assertLog([<span class="string">'Message Event'</span>, <span class="string">'Task'</span>]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="2-task-with-continuation"><a href="#2-task-with-continuation" class="headerlink" title="2. task with continuation"></a>2. task with continuation</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'task with continuation'</span>, () =&gt; &#123;</span><br><span class="line">  scheduleCallback(NormalPriority, () =&gt; &#123;</span><br><span class="line">    runtime.log(<span class="string">'Task'</span>);</span><br><span class="line">    <span class="keyword">while</span> (!Scheduler.unstable_shouldYield()) &#123;</span><br><span class="line">      runtime.advanceTime(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    runtime.log(<span class="string">`Yield at <span class="subst">$&#123;performance.now()&#125;</span>ms`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      runtime.log(<span class="string">'Continuation'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">  runtime.assertLog([<span class="string">'Post Message'</span>]);</span><br><span class="line"></span><br><span class="line">  runtime.fireMessageEvent();</span><br><span class="line">  runtime.assertLog([</span><br><span class="line">    <span class="string">'Message Event'</span>,</span><br><span class="line">    <span class="string">'Task'</span>,</span><br><span class="line">    <span class="string">'Yield at 5ms'</span>,</span><br><span class="line">    <span class="string">'Post Message'</span>,</span><br><span class="line">  ]);</span><br><span class="line"></span><br><span class="line">  runtime.fireMessageEvent();</span><br><span class="line">  runtime.assertLog([<span class="string">'Message Event'</span>, <span class="string">'Continuation'</span>]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>callback 返回子work，但是会在下一个 message event 事件中执行</p>
<h5 id="3-multiple-tasks"><a href="#3-multiple-tasks" class="headerlink" title="3. multiple tasks"></a>3. multiple tasks</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'multiple tasks'</span>, () =&gt; &#123;</span><br><span class="line">  scheduleCallback(NormalPriority, () =&gt; &#123;</span><br><span class="line">    runtime.log(<span class="string">'A'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  scheduleCallback(NormalPriority, () =&gt; &#123;</span><br><span class="line">    runtime.log(<span class="string">'B'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  runtime.assertLog([<span class="string">'Post Message'</span>]);</span><br><span class="line">  runtime.fireMessageEvent();</span><br><span class="line">  runtime.assertLog([<span class="string">'Message Event'</span>, <span class="string">'A'</span>, <span class="string">'B'</span>]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="4-multiple-tasks-with-a-yield-in-between"><a href="#4-multiple-tasks-with-a-yield-in-between" class="headerlink" title="4. multiple tasks with a yield in between"></a>4. multiple tasks with a yield in between</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'multiple tasks with a yield in between'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 时间切片为5ms，当设置时间4999之后时，当前时间切片已经用完，所以yield之后，异步执行下一个task</span></span><br><span class="line"></span><br><span class="line">  scheduleCallback(NormalPriority, () =&gt; &#123;</span><br><span class="line">    runtime.log(<span class="string">'A'</span>);</span><br><span class="line">    runtime.advanceTime(<span class="number">4999</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  scheduleCallback(NormalPriority, () =&gt; &#123;</span><br><span class="line">    runtime.log(<span class="string">'B'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  runtime.assertLog([<span class="string">'Post Message'</span>]);</span><br><span class="line">  runtime.fireMessageEvent();</span><br><span class="line">  runtime.assertLog([</span><br><span class="line">    <span class="string">'Message Event'</span>,</span><br><span class="line">    <span class="string">'A'</span>,</span><br><span class="line">    <span class="comment">// Ran out of time. Post a continuation event.</span></span><br><span class="line">    <span class="string">'Post Message'</span>,</span><br><span class="line">  ]);</span><br><span class="line">  runtime.fireMessageEvent();</span><br><span class="line">  runtime.assertLog([<span class="string">'Message Event'</span>, <span class="string">'B'</span>]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="5-throws-when-a-task-errors-then-continues-in-a-new-event"><a href="#5-throws-when-a-task-errors-then-continues-in-a-new-event" class="headerlink" title="5. throws when a task errors then continues in a new event"></a>5. throws when a task errors then continues in a new event</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'throws when a task errors then continues in a new event'</span>, () =&gt; &#123;</span><br><span class="line">  scheduleCallback(NormalPriority, () =&gt; &#123;</span><br><span class="line">    runtime.log(<span class="string">'Oops!'</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'Oops!'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  scheduleCallback(NormalPriority, () =&gt; &#123;</span><br><span class="line">    runtime.log(<span class="string">'Yay'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  runtime.assertLog([<span class="string">'Post Message'</span>]);</span><br><span class="line"></span><br><span class="line">  expect(<span class="function"><span class="params">()</span> =&gt;</span> runtime.fireMessageEvent()).toThrow(<span class="string">'Oops!'</span>);</span><br><span class="line">  runtime.assertLog([<span class="string">'Message Event'</span>, <span class="string">'Oops!'</span>, <span class="string">'Post Message'</span>]);</span><br><span class="line"></span><br><span class="line">  runtime.fireMessageEvent();</span><br><span class="line">  runtime.assertLog([<span class="string">'Message Event'</span>, <span class="string">'Yay'</span>]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果 task 执行报错，后面的任务会在下一个 message event 中继续执行 因为在 workLoop 中在执行任务前会先将 task.callback 设置为null，就是取消任务 </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/OPY-bbt/2020/08/23/代码大全/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="山石岩">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/16717283?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前路漫漫 唯风作伴">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/23/代码大全/" itemprop="url">代码大全</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-23T11:17:53+08:00">
                2020-08-23
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/08/23/代码大全/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/08/23/代码大全/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="软件的首要技术使命：管理复杂度"><a href="#软件的首要技术使命：管理复杂度" class="headerlink" title="软件的首要技术使命：管理复杂度"></a>软件的首要技术使命：管理复杂度</h3><p>本质的问题和偶然的问题，导致软件开发变得困难<br>在软件架构的层次上，可以通过把整个系统分解为多个子系统来降低问题的复杂度</p>
<p>解决复杂度：<br>把任何人在同一时间需要处理的本质复杂度的量减少到最低<br>不要让偶然性的复杂度无谓的快速增长</p>
<h3 id="理想的设计特征"><a href="#理想的设计特征" class="headerlink" title="理想的设计特征"></a>理想的设计特征</h3><ul>
<li>最小的复杂度</li>
<li>易于维护</li>
<li>松散耦合</li>
<li>可扩展性</li>
<li>可重用行</li>
<li>高扇入。让大量的类使用某个给定的类。意味着设计出得系统很好的利用了在较低层次上的工具类</li>
<li>低扇出。让一个类较少量或者适中的使用其他的类。不超过7个。</li>
<li>可移植性</li>
<li>精简性</li>
<li>层次性</li>
<li>标准技术</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/OPY-bbt/2020/08/01/数据结构与算法-基础题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="山石岩">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/16717283?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前路漫漫 唯风作伴">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/01/数据结构与算法-基础题/" itemprop="url">数据结构与算法-基础题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-01T09:26:11+08:00">
                2020-08-01
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/08/01/数据结构与算法-基础题/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/08/01/数据结构与算法-基础题/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h3><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><h3 id="约瑟夫问题"><a href="#约瑟夫问题" class="headerlink" title="约瑟夫问题"></a>约瑟夫问题</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环链表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.val = val;</span><br><span class="line">    <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create_linkList</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> head = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> pre = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> node = <span class="keyword">new</span> Node(i);</span><br><span class="line">        pre.next = node;</span><br><span class="line">        pre = node;</span><br><span class="line">    &#125;</span><br><span class="line">    pre.next = head;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> all = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">const</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> list = create_linkList(all);</span><br><span class="line">    <span class="keyword">let</span> pre = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> cur = list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(cur.next !== cur) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(cur.val);</span><br><span class="line">&#125;</span><br><span class="line">main();</span><br></pre></td></tr></table></figure>
<h3 id="链表反转"><a href="#链表反转" class="headerlink" title="链表反转"></a>链表反转</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseList</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// head 为哨兵节点，不需要反转</span></span><br><span class="line">    <span class="keyword">let</span> currentNode = head.next;</span><br><span class="line">    <span class="keyword">let</span> previousNode = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(currentNode) &#123;</span><br><span class="line">        <span class="keyword">let</span> nextNode = currentNode.next;</span><br><span class="line"></span><br><span class="line">        currentNode.next = previousNode;</span><br><span class="line"></span><br><span class="line">        previousNode = currentNode;</span><br><span class="line"></span><br><span class="line">        currentNode = nextNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    head.next = previousNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="检测链表中的环"><a href="#检测链表中的环" class="headerlink" title="检测链表中的环"></a>检测链表中的环</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkCircle</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fast = head.next;</span><br><span class="line">    <span class="keyword">let</span> slow = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast.next) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="keyword">if</span>(slow === fast) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链表中间节点"><a href="#链表中间节点" class="headerlink" title="链表中间节点"></a>链表中间节点</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findMiddleNode</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fast = <span class="keyword">this</span>.head;</span><br><span class="line">    <span class="keyword">let</span> slow = <span class="keyword">this</span>.head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fast.next &amp;&amp; fast.next.next) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><h3 id="求阶乘"><a href="#求阶乘" class="headerlink" title="求阶乘"></a>求阶乘</h3><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><h3 id="二叉树的高度"><a href="#二叉树的高度" class="headerlink" title="二叉树的高度"></a>二叉树的高度</h3><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h3 id="八皇后"><a href="#八皇后" class="headerlink" title="八皇后"></a>八皇后</h3><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><h3 id="DFS-的递归代码"><a href="#DFS-的递归代码" class="headerlink" title="DFS 的递归代码"></a>DFS 的递归代码</h3><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><h3 id="二分查找变体"><a href="#二分查找变体" class="headerlink" title="二分查找变体"></a>二分查找变体</h3><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><h3 id="堆的三种应用（优先级队列、Top-k、中位数）"><a href="#堆的三种应用（优先级队列、Top-k、中位数）" class="headerlink" title="堆的三种应用（优先级队列、Top k、中位数）"></a>堆的三种应用（优先级队列、Top k、中位数）</h3><h3 id="字符串匹配-BF-算法"><a href="#字符串匹配-BF-算法" class="headerlink" title="字符串匹配 BF 算法"></a>字符串匹配 BF 算法</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/OPY-bbt/2020/07/15/webpack代理实现原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="山石岩">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/16717283?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前路漫漫 唯风作伴">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/15/webpack代理实现原理/" itemprop="url">webpack代理实现原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-15T22:53:46+08:00">
                2020-07-15
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/07/15/webpack代理实现原理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/07/15/webpack代理实现原理/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/OPY-bbt/2020/07/13/回溯算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="山石岩">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/16717283?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前路漫漫 唯风作伴">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/13/回溯算法/" itemprop="url">算法思想-回溯</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-13T21:44:13+08:00">
                2020-07-13
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/07/13/回溯算法/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/07/13/回溯算法/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>笼统地讲，回溯算法很多时候都应用在“搜索”这类问题上。不过这里说的搜索，并不是狭义的指我们前面讲过的图的搜索算法，而是在一组可能的解中，搜索满足期望的解。回溯的处理思想，有点类似枚举搜索。我们枚举所有的解，找到满足期望的解。</code></p>
<h3 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h3><p>在8*8的棋盘上放置8个棋子，并且保证行列，左右对角线上都没有棋子。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cal8queens</span>(<span class="params">row</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (row === <span class="number">8</span>) &#123;</span><br><span class="line">        printQueens(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历列，如果符合要求则进入下一行，DFS</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> column = <span class="number">0</span>; column &lt; <span class="number">8</span>; column++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isOk(row, column)) &#123;</span><br><span class="line">            result[row] = column;</span><br><span class="line">            cal8queens(row + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isOk</span>(<span class="params">row, column</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> leftup = column - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> rightup = column + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = row - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (result[i] === column) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 同一列有值，失败</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (leftup &gt;= <span class="number">0</span>) &#123; <span class="comment">// 左对角线有值，失败</span></span><br><span class="line">            <span class="keyword">if</span> (result[i] == leftup) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (rightup &lt; <span class="number">8</span>) &#123; <span class="comment">//  右对角线有值，失败</span></span><br><span class="line">            <span class="keyword">if</span> (result[i] == rightup) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        leftup--;</span><br><span class="line">        rightup++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printQueens</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> row = <span class="number">0</span>; row &lt; <span class="number">8</span>; row++) &#123;</span><br><span class="line">        <span class="keyword">let</span> s = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> column = <span class="number">0</span>; column &lt; <span class="number">8</span>; column++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (result[row] === column) s += <span class="string">"Q "</span>;</span><br><span class="line">            <span class="keyword">else</span> s += <span class="string">"* "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(s + <span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"-----------\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">cal8queens(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h3><p>我们有一个背包，背包总的承载重量是 Wkg。现在我们有 n 个物品，每个物品的重量不等，并且不可分割。我们现在期望选择几件物品，装载到背包中。在不超过背包所能装载重量的前提下，如何让背包中物品的总重量最大？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> maxW = <span class="number">0</span>; <span class="comment">// 存储背包中物品总质量的最大值</span></span><br><span class="line"><span class="comment">// i表示考察到哪个物品了；</span></span><br><span class="line"><span class="comment">// cw 表示当前已经装进去的物品的重量和；</span></span><br><span class="line"><span class="comment">// items 物品重量</span></span><br><span class="line"><span class="comment">// n 物品数量；</span></span><br><span class="line"><span class="comment">// w 背包重量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">i, cw, items, n, w</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cw == w || i == n) &#123; <span class="comment">// 装满了或者考察完所有物品</span></span><br><span class="line">        <span class="keyword">if</span> (cw &gt; maxW) maxW = cw;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于第i个物品，会有装或者不装两种情况</span></span><br><span class="line">    <span class="comment">// 不装第i个物品</span></span><br><span class="line">    f(i+<span class="number">1</span>, cw, items, n, w);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 装第i个物品</span></span><br><span class="line">    <span class="keyword">if</span> (cw + items[i] &lt;= w) &#123;</span><br><span class="line">        f(i + <span class="number">1</span>, cw + items[i], items, n, w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>假设正则表达式中只包含“<em>”和“?”这两种通配符，并且对这两个通配符的语义稍微做些改变，其中，“</em>”匹配任意多个（大于等于 0 个）任意字符，“?”匹配零个或者一个任意字符。基于以上背景假设，我们看下，如何用回溯算法，判断一个给定的文本，能否跟给定的正则表达式匹配？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ti 第i个text字符</span></span><br><span class="line"><span class="comment">// pj 第i个正则字符</span></span><br><span class="line"><span class="comment">// text 文本</span></span><br><span class="line"><span class="comment">// tlen 文本长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> matched = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">const</span> pattern = <span class="string">""</span>; <span class="comment">// 正则</span></span><br><span class="line"><span class="keyword">const</span> plen = pattern.length;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">match</span>(<span class="params">ti, pj, text, tlen</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matched) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pj == plen) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ti === tlen) matched = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pattern[pj] === <span class="string">"*"</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt;= tlen - ti; k ++) &#123;</span><br><span class="line">            match(ti + k, pj + <span class="number">1</span>, text, tlen);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pattern[pj] === <span class="string">"?"</span>) &#123;</span><br><span class="line">        <span class="comment">// 匹配0个字符</span></span><br><span class="line">        match(ti, pj+<span class="number">1</span>, text, tlen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匹配1个字符</span></span><br><span class="line">        match(ti + <span class="number">1</span>, pj + <span class="number">1</span>, text, tlen);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ti &lt; tlen &amp;&amp; pattern[pj] == text[ti]) &#123;</span><br><span class="line">        match(ti + <span class="number">1</span>, pj + <span class="number">1</span>, text, tlen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回溯算法的思想非常简单，大部分情况下，都是用来解决广义的搜索问题，也就是，从一组可能的解中，选择出一个满足要求的解。回溯算法非常适合用递归来实现，</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/OPY-bbt/2020/06/13/从测试看react源码-scheduler/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="山石岩">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/16717283?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前路漫漫 唯风作伴">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/13/从测试看react源码-scheduler/" itemprop="url">从测试看react源码_scheduler</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-13T16:25:11+08:00">
                2020-06-13
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/06/13/从测试看react源码-scheduler/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/06/13/从测试看react源码-scheduler/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>这是从测试看react源码的第一篇，先从一个独立的 Scheduler 模块入手。正如官方所说，Scheduler模块是一个用于协作调度任务的包，防止浏览器主线程长时间忙于运行一些事情，关键任务的执行被推迟。用于 react 内部，现在将它独立出来，将来会成为公开API</code></p>
<h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><ul>
<li>下载源码到本地，我使用的分支是 master(4c7036e80)</li>
<li>由于 react 测试代码太多，如果想要仅测试 scheduler 部分代码，需要修改一下jest配置</li>
<li><p>打开 package.json，可以看到 test 命令的配置文件是 config.source.js</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;test&quot;: &quot;cross-env NODE_ENV=development jest --config ./scripts/jest/config.source.js&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在其中我们可以看到又引入了 config.base.js 文件，接下来就是修改 config.base.js</p>
  <figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- testRegex: '/__tests__/[^/]*(\\.js|\\.coffee|[^d]\\.ts)$',</span></span><br><span class="line"><span class="addition">+ testRegex: '/__tests__/Scheduler-test.js',</span></span><br><span class="line">moduleFileExtensions: ['js', 'json', 'node', 'coffee', 'ts'],</span><br><span class="line">rootDir: process.cwd(),</span><br><span class="line"><span class="deletion">- roots: ['&lt;rootDir&gt;/packages', '&lt;rootDir&gt;/scripts'],</span></span><br><span class="line"><span class="addition">+ roots: ['&lt;rootDir&gt;/packages/scheduler'],</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在项目根目录下运行 yarn run test，不出意外会看到测试成功运行</p>
</li>
</ul>
<h3 id="jest-相关介绍"><a href="#jest-相关介绍" class="headerlink" title="jest 相关介绍"></a>jest 相关介绍</h3><p>在开始之前，先了解一下jest的运行环境，省的一会找不到代码对应位置</p>
<ul>
<li>jest.mock()用于mock某个模块，比如<code>jest.mock(&#39;scheduler&#39;, () =&gt; require(&#39;scheduler/unstable_mock&#39;));</code>， 那么之后 <code>require(&#39;scheduler&#39;)</code> 其实就是引入的 <code>scheduler/unstable_mock.js</code></li>
<li>如果你看到以 hostConfig 结尾的文件名中内容是 <code>throw new Error(&#39;This module must be shimmed by a specific build.&#39;);</code>，那么就去 <code>scripts/jest/setupHostConfig.js</code>中去查看到底使用了哪个文件。</li>
<li>expect(xx).Function() 这里的 Function 被称为 matcher。 在 jest 中有些默认的 matcher，比如说 toEqual,也可以自定义。scripts/jest/matchers 就是一些 react 自定义的。</li>
</ul>
<h3 id="miniHeap"><a href="#miniHeap" class="headerlink" title="miniHeap"></a>miniHeap</h3><p>scheduler 用于调度任务，防止浏览器主线程长时间忙于运行一些事情，关键任务的执行却被推迟。那么任务就要有一个优先级，每次优先执行优先级最高的任务。在 schuduler 中有两个任务队列，taskQueue 和 timerQueue 队列，是最小堆实现的优先队列。数组第一项永远为优先级最高的子项。</p>
<h3 id="Scheduler-test-js"><a href="#Scheduler-test-js" class="headerlink" title="Scheduler-test.js"></a>Scheduler-test.js</h3><h5 id="1-flushes-work-incrementally"><a href="#1-flushes-work-incrementally" class="headerlink" title="1. flushes work incrementally"></a>1. flushes work incrementally</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">it(&apos;flushes work incrementally&apos;, () =&gt; &#123;</span><br><span class="line">  scheduleCallback(NormalPriority, () =&gt; Scheduler.unstable_yieldValue(&apos;A&apos;));</span><br><span class="line">  scheduleCallback(NormalPriority, () =&gt; Scheduler.unstable_yieldValue(&apos;B&apos;));</span><br><span class="line">  scheduleCallback(NormalPriority, () =&gt; Scheduler.unstable_yieldValue(&apos;C&apos;));</span><br><span class="line">  scheduleCallback(NormalPriority, () =&gt; Scheduler.unstable_yieldValue(&apos;D&apos;));</span><br><span class="line"></span><br><span class="line">  expect(Scheduler).toFlushAndYieldThrough([&apos;A&apos;, &apos;B&apos;]);</span><br><span class="line">  expect(Scheduler).toFlushAndYieldThrough([&apos;C&apos;]);</span><br><span class="line">  expect(Scheduler).toFlushAndYield([&apos;D&apos;]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>Scheduler.unstable_yieldValue</code> 函数比较简单，就是将参数push到一个数组中，用于结果的比较。<br><code>scheduleCallback</code> 中会构造 Task, 如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 构造Task</span><br><span class="line">var newTask = &#123;</span><br><span class="line">  id: taskIdCounter++,</span><br><span class="line">  callback,</span><br><span class="line">  priorityLevel,</span><br><span class="line">  startTime,</span><br><span class="line">  expirationTime,</span><br><span class="line">  sortIndex: -1,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>并将其加入 taskQueue 或者 timerQueue。如果当前没有任务在执行则调用 <code>requestHostCallback(flushWork);</code> 用于执行任务。<br>在测试环境中 requestHostCallback 的实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export function requestHostCallback(callback: boolean =&gt; void) &#123;</span><br><span class="line">  scheduledCallback = callback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>仅仅是保存了 flushWork 函数, 并没有执行。<br>传入的 <code>flushWork</code> 函数返回 boolean 变量，当 true 时为有 task 可以执行，但是当前时间切片已结束，将空出主线程给浏览器。其中执行 <code>workLoop</code>，<code>workLoop</code> 是任务执行的真正地方。其首先会从当前 timerQueue 中取出定时已经到期的timer，将其加入到 taskQueue 中。接来下就是取出 taskQueue 中的任务并执行。<code>workLoop</code> 代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// 取出已经到时的 timer，放入 taskQueue 中。</span><br><span class="line">advanceTimers(currentTime);</span><br><span class="line"></span><br><span class="line">currentTask = peek(taskQueue);</span><br><span class="line">while (</span><br><span class="line">  currentTask !== null &amp;&amp;</span><br><span class="line">  !(enableSchedulerDebugging &amp;&amp; isSchedulerPaused)</span><br><span class="line">) &#123;</span><br><span class="line">  if (</span><br><span class="line">    currentTask.expirationTime &gt; currentTime &amp;&amp;</span><br><span class="line">    (!hasTimeRemaining || shouldYieldToHost())</span><br><span class="line">  ) &#123;</span><br><span class="line">    // This currentTask hasn&apos;t expired, and we&apos;ve reached the deadline.</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line">  const callback = currentTask.callback;</span><br><span class="line">  if (callback !== null) &#123;</span><br><span class="line">    currentTask.callback = null;</span><br><span class="line">    currentPriorityLevel = currentTask.priorityLevel;</span><br><span class="line">    const didUserCallbackTimeout = currentTask.expirationTime &lt;= currentTime;</span><br><span class="line">    markTaskRun(currentTask, currentTime);</span><br><span class="line">    const continuationCallback = callback(didUserCallbackTimeout);</span><br><span class="line">    currentTime = getCurrentTime();</span><br><span class="line"></span><br><span class="line">    if (typeof continuationCallback === &apos;function&apos;) &#123;</span><br><span class="line">      // 当前任务执行过程中被中断，则将之后需要继续执行的callback保存下来</span><br><span class="line">      currentTask.callback = continuationCallback;</span><br><span class="line">      markTaskYield(currentTask, currentTime);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      if (enableProfiling) &#123;</span><br><span class="line">        markTaskCompleted(currentTask, currentTime);</span><br><span class="line">        currentTask.isQueued = false;</span><br><span class="line">      &#125;</span><br><span class="line">      if (currentTask === peek(taskQueue)) &#123;</span><br><span class="line">        pop(taskQueue);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    advanceTimers(currentTime);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 已经取消的任务，调用unstable_cancelCallback方法取消任务</span><br><span class="line">    pop(taskQueue);</span><br><span class="line">  &#125;</span><br><span class="line">  currentTask = peek(taskQueue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>循环取出 taskQueue 中的任务，直到 taskQueue 为空，或者当前时间切片时间已到并且任务也还没有过期，中断循环。把任务放到下一个时间切片执行。注意一下 <code>shouldYieldToHost()</code>，这个也是判断是否继续执行的条件，之后会用到。</p>
<p>1-4 行代码结果就是将四个 task 推入taskQueue，等待执行。然后去看一下 matcher <code>toFlushAndYieldThrough</code>, 位置在 <code>scripts/jest/matchers/schedulerTestMatchers.js</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function toFlushAndYieldThrough(Scheduler, expectedYields) &#123;</span><br><span class="line">  assertYieldsWereCleared(Scheduler);</span><br><span class="line">  Scheduler.unstable_flushNumberOfYields(expectedYields.length);</span><br><span class="line">  const actualYields = Scheduler.unstable_clearYields();</span><br><span class="line">  return captureAssertion(() =&gt; &#123;</span><br><span class="line">    expect(actualYields).toEqual(expectedYields);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行与 expectedYields(就是test里的[‘A’, ‘B’]，[‘C’]，[‘D’] ) 数量相同的任务，看结果是否相等<br><code>unstable_flushNumberOfYields</code> 代码如下，这里的cb就是 flushWork，第一个参数为 true表示当前切片有剩余时间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">export function unstable_flushNumberOfYields(count: number): void &#123;</span><br><span class="line">  if (isFlushing) &#123;</span><br><span class="line">    throw new Error(&apos;Already flushing work.&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  if (scheduledCallback !== null) &#123;</span><br><span class="line">    const cb = scheduledCallback;</span><br><span class="line">    expectedNumberOfYields = count;</span><br><span class="line">    isFlushing = true;</span><br><span class="line">    try &#123;</span><br><span class="line">      let hasMoreWork = true;</span><br><span class="line">      do &#123;</span><br><span class="line">        // 执行任务</span><br><span class="line">        hasMoreWork = cb(true, currentTime);</span><br><span class="line">      &#125; while (hasMoreWork &amp;&amp; !didStop);</span><br><span class="line">      if (!hasMoreWork) &#123;</span><br><span class="line">        scheduledCallback = null;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      expectedNumberOfYields = -1;</span><br><span class="line">      didStop = false;</span><br><span class="line">      isFlushing = false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么何时停止呢？记得之前的 <code>shouldYieldToHost</code> 函数吗，在 schedulerHostConfig.mock.js 在实现了此函数，并且添加了一个 didStop 变量用于测试中控制数量，当达到 expectedNumberOfYields 数量时退出循环。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">export function shouldYieldToHost(): boolean &#123;</span><br><span class="line">  if (</span><br><span class="line">    (expectedNumberOfYields !== -1 &amp;&amp;</span><br><span class="line">      yieldedValues !== null &amp;&amp;</span><br><span class="line">      yieldedValues.length &gt;= expectedNumberOfYields) ||</span><br><span class="line">    (shouldYieldForPaint &amp;&amp; needsPaint)</span><br><span class="line">  ) &#123;</span><br><span class="line">    // We yielded at least as many values as expected. Stop flushing.</span><br><span class="line">    didStop = true;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="2-cancels-work"><a href="#2-cancels-work" class="headerlink" title="2. cancels work"></a>2. cancels work</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">it(&apos;cancels work&apos;, () =&gt; &#123;</span><br><span class="line">  scheduleCallback(NormalPriority, () =&gt; Scheduler.unstable_yieldValue(&apos;A&apos;));</span><br><span class="line">  const callbackHandleB = scheduleCallback(NormalPriority, () =&gt;</span><br><span class="line">    Scheduler.unstable_yieldValue(&apos;B&apos;),</span><br><span class="line">  );</span><br><span class="line">  scheduleCallback(NormalPriority, () =&gt; Scheduler.unstable_yieldValue(&apos;C&apos;));</span><br><span class="line"></span><br><span class="line">  // 取消任务即把task.callback设置为null，</span><br><span class="line">  cancelCallback(callbackHandleB);</span><br><span class="line"></span><br><span class="line">  expect(Scheduler).toFlushAndYield([</span><br><span class="line">    &apos;A&apos;,</span><br><span class="line">    // B should have been cancelled</span><br><span class="line">    &apos;C&apos;,</span><br><span class="line">  ]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>将task callback 设置为 null 就是取消任务，这部分在 workLoop里有判断</p>
<h5 id="3-executes-the-highest-priority-callbacks-first"><a href="#3-executes-the-highest-priority-callbacks-first" class="headerlink" title="3. executes the highest priority callbacks first"></a>3. executes the highest priority callbacks first</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">it(&apos;executes the highest priority callbacks first&apos;, () =&gt; &#123;</span><br><span class="line">  // 这加入taskQueue时，用最小堆排序算法排序的</span><br><span class="line"></span><br><span class="line">  scheduleCallback(NormalPriority, () =&gt; Scheduler.unstable_yieldValue(&apos;A&apos;));</span><br><span class="line">  scheduleCallback(NormalPriority, () =&gt; Scheduler.unstable_yieldValue(&apos;B&apos;));</span><br><span class="line"></span><br><span class="line">  // Yield before B is flushed</span><br><span class="line">  expect(Scheduler).toFlushAndYieldThrough([&apos;A&apos;]);</span><br><span class="line"></span><br><span class="line">  scheduleCallback(UserBlockingPriority, () =&gt;</span><br><span class="line">    Scheduler.unstable_yieldValue(&apos;C&apos;),</span><br><span class="line">  );</span><br><span class="line">  scheduleCallback(UserBlockingPriority, () =&gt;</span><br><span class="line">    Scheduler.unstable_yieldValue(&apos;D&apos;),</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  // C and D should come first, because they are higher priority</span><br><span class="line">  expect(Scheduler).toFlushAndYield([&apos;C&apos;, &apos;D&apos;, &apos;B&apos;]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在 scheduler 中定义了6中优先级:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export const NoPriority = 0;</span><br><span class="line">export const ImmediatePriority = 1;</span><br><span class="line">export const UserBlockingPriority = 2;</span><br><span class="line">export const NormalPriority = 3;</span><br><span class="line">export const LowPriority = 4;</span><br><span class="line">export const IdlePriority = 5;</span><br></pre></td></tr></table></figure></p>
<p>每种优先级又对应了不同的超时时间:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Times out immediately</span><br><span class="line">var IMMEDIATE_PRIORITY_TIMEOUT = -1;</span><br><span class="line">// Eventually times out</span><br><span class="line">var USER_BLOCKING_PRIORITY_TIMEOUT = 250;</span><br><span class="line">var NORMAL_PRIORITY_TIMEOUT = 5000;</span><br><span class="line">var LOW_PRIORITY_TIMEOUT = 10000;</span><br><span class="line">// Never times out</span><br><span class="line">var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;</span><br></pre></td></tr></table></figure></p>
<p>其中 NoPriority 和 NormalPriority 的超时时间一样,这可以在 scheduler.js中看到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function timeoutForPriorityLevel(priorityLevel) &#123;</span><br><span class="line">  switch (priorityLevel) &#123;</span><br><span class="line">    case ImmediatePriority:</span><br><span class="line">      return IMMEDIATE_PRIORITY_TIMEOUT;</span><br><span class="line">    case UserBlockingPriority:</span><br><span class="line">      return USER_BLOCKING_PRIORITY_TIMEOUT;</span><br><span class="line">    case IdlePriority:</span><br><span class="line">      return IDLE_PRIORITY_TIMEOUT;</span><br><span class="line">    case LowPriority:</span><br><span class="line">      return LOW_PRIORITY_TIMEOUT;</span><br><span class="line">    case NormalPriority:</span><br><span class="line">    default:</span><br><span class="line">      return NORMAL_PRIORITY_TIMEOUT;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在新建任务时会根据当前时间和超时时间计算出过期时间，taskQueue 是按照过期时间排序的。优先级高的任务，过期时间就会越小，所以会先被执行。</p>
<h5 id="4-expires-work"><a href="#4-expires-work" class="headerlink" title="4. expires work"></a>4. expires work</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">it(&apos;expires work&apos;, () =&gt; &#123;</span><br><span class="line">    scheduleCallback(NormalPriority, didTimeout =&gt; &#123;</span><br><span class="line">      Scheduler.unstable_advanceTime(100);</span><br><span class="line">      Scheduler.unstable_yieldValue(`A (did timeout: $&#123;didTimeout&#125;)`);</span><br><span class="line">    &#125;);</span><br><span class="line">    scheduleCallback(UserBlockingPriority, didTimeout =&gt; &#123;</span><br><span class="line">      Scheduler.unstable_advanceTime(100);</span><br><span class="line">      Scheduler.unstable_yieldValue(`B (did timeout: $&#123;didTimeout&#125;)`);</span><br><span class="line">    &#125;);</span><br><span class="line">    scheduleCallback(UserBlockingPriority, didTimeout =&gt; &#123;</span><br><span class="line">      Scheduler.unstable_advanceTime(100);</span><br><span class="line">      Scheduler.unstable_yieldValue(`C (did timeout: $&#123;didTimeout&#125;)`);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // Advance time, but not by enough to expire any work</span><br><span class="line">    Scheduler.unstable_advanceTime(249);</span><br><span class="line">    expect(Scheduler).toHaveYielded([]);</span><br><span class="line"></span><br><span class="line">    // Schedule a few more callbacks</span><br><span class="line">    scheduleCallback(NormalPriority, didTimeout =&gt; &#123;</span><br><span class="line">      Scheduler.unstable_advanceTime(100);</span><br><span class="line">      Scheduler.unstable_yieldValue(`D (did timeout: $&#123;didTimeout&#125;)`);</span><br><span class="line">    &#125;);</span><br><span class="line">    scheduleCallback(NormalPriority, didTimeout =&gt; &#123;</span><br><span class="line">      Scheduler.unstable_advanceTime(100);</span><br><span class="line">      Scheduler.unstable_yieldValue(`E (did timeout: $&#123;didTimeout&#125;)`);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // Advance by just a bit more to expire the user blocking callbacks</span><br><span class="line"></span><br><span class="line">    // currentTime被设置成249 + 1 而 UserBlockingPriority 的timeout为250，所以超时执行</span><br><span class="line">    Scheduler.unstable_advanceTime(1);</span><br><span class="line">    expect(Scheduler).toFlushExpired([</span><br><span class="line">      &apos;B (did timeout: true)&apos;,</span><br><span class="line">      &apos;C (did timeout: true)&apos;,</span><br><span class="line">    ]);</span><br><span class="line"></span><br><span class="line">    // Expire A</span><br><span class="line">    // 250 + 100 + 100 + 4600 = 5050 &gt; 5000(NORMAL_PRIORITY_TIMEOUT)</span><br><span class="line">    Scheduler.unstable_advanceTime(4600);</span><br><span class="line">    expect(Scheduler).toFlushExpired([&apos;A (did timeout: true)&apos;]);</span><br><span class="line"></span><br><span class="line">    // Flush the rest without expiring</span><br><span class="line">    expect(Scheduler).toFlushAndYield([</span><br><span class="line">      &apos;D (did timeout: false)&apos;,</span><br><span class="line">      &apos;E (did timeout: true)&apos;,</span><br><span class="line">    ]);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>UserBlockingPriority 类型的任务，新建 task 时设置过期时间为当前时间 + USER_BLOCKING_PRIORITY_TIMEOUT（250）， 而 NormalPriority 则为 当前时间 + NORMAL_PRIORITY_TIMEOUT（5000）。<br>unstable_advanceTime 作用是就是增量当前时间。比如 unstable_advanceTime(100)，意味这当前时间增加了 100ms，如果当前时间大于过期时间，则任务过期。<br>在最后调用 scheduledCallback 时, 代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">export function unstable_flushExpired() &#123;</span><br><span class="line">  if (isFlushing) &#123;</span><br><span class="line">    throw new Error(&apos;Already flushing work.&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  if (scheduledCallback !== null) &#123;</span><br><span class="line">    isFlushing = true;</span><br><span class="line">    try &#123;</span><br><span class="line">      const hasMoreWork = scheduledCallback(false, currentTime);</span><br><span class="line">      if (!hasMoreWork) &#123;</span><br><span class="line">        scheduledCallback = null;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      isFlushing = false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在其中调用 scheduledCallback(也就是 flushWork) 时将 hasTimeRemaining 参数设置为false，当前时间切片未有剩余，仅任务过期才会执行，未过期则放到下一个时间切片执行。这里的第一个测试  Scheduler.unstable_advanceTime(249)，有些多余，不管设置成多少都不会有变化。<br>这里需要注意的是D， E 任务过期时间为 5249，所以最后 D 任务没有过期 而 E 任务过期了。</p>
<h5 id="5-continues-working-on-same-task-after-yielding"><a href="#5-continues-working-on-same-task-after-yielding" class="headerlink" title="5. continues working on same task after yielding"></a>5. continues working on same task after yielding</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">it(&apos;continues working on same task after yielding&apos;, () =&gt; &#123;</span><br><span class="line">  // workLoop 中如果callback执行之后返回函数，会把返回的函数再次存入task对象的callback中保存下来</span><br><span class="line">  scheduleCallback(NormalPriority, () =&gt; &#123;</span><br><span class="line">    Scheduler.unstable_advanceTime(100);</span><br><span class="line">    Scheduler.unstable_yieldValue(&apos;A&apos;);</span><br><span class="line">  &#125;);</span><br><span class="line">  scheduleCallback(NormalPriority, () =&gt; &#123;</span><br><span class="line">    Scheduler.unstable_advanceTime(100);</span><br><span class="line">    Scheduler.unstable_yieldValue(&apos;B&apos;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  let didYield = false;</span><br><span class="line">  const tasks = [</span><br><span class="line">    [&apos;C1&apos;, 100],</span><br><span class="line">    [&apos;C2&apos;, 100],</span><br><span class="line">    [&apos;C3&apos;, 100],</span><br><span class="line">  ];</span><br><span class="line">  const C = () =&gt; &#123;</span><br><span class="line">    while (tasks.length &gt; 0) &#123;</span><br><span class="line">      const [label, ms] = tasks.shift();</span><br><span class="line">      Scheduler.unstable_advanceTime(ms);</span><br><span class="line">      Scheduler.unstable_yieldValue(label);</span><br><span class="line">      if (shouldYield()) &#123;</span><br><span class="line">        didYield = true;</span><br><span class="line">        return C;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  scheduleCallback(NormalPriority, C);</span><br><span class="line"></span><br><span class="line">  scheduleCallback(NormalPriority, () =&gt; &#123;</span><br><span class="line">    Scheduler.unstable_advanceTime(100);</span><br><span class="line">    Scheduler.unstable_yieldValue(&apos;D&apos;);</span><br><span class="line">  &#125;);</span><br><span class="line">  scheduleCallback(NormalPriority, () =&gt; &#123;</span><br><span class="line">    Scheduler.unstable_advanceTime(100);</span><br><span class="line">    Scheduler.unstable_yieldValue(&apos;E&apos;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // Flush, then yield while in the middle of C.</span><br><span class="line">  expect(didYield).toBe(false);</span><br><span class="line">  expect(Scheduler).toFlushAndYieldThrough([&apos;A&apos;, &apos;B&apos;, &apos;C1&apos;]);</span><br><span class="line">  expect(didYield).toBe(true);</span><br><span class="line"></span><br><span class="line">  // When we resume, we should continue working on C.</span><br><span class="line">  expect(Scheduler).toFlushAndYield([&apos;C2&apos;, &apos;C3&apos;, &apos;D&apos;, &apos;E&apos;]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这里主要看下任务C，其 callback 其最后又返回了自身，相当于任务的子任务，被中断之后，下一个时间切片继续执行子任务。子任务继承了父任务的所有参数，当执行完当前子任务之后，仅仅需要设置父任务 callback 函数为下一个子任务 callback，在 workLoop 中的相关代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const continuationCallback = callback(didUserCallbackTimeout);</span><br><span class="line">currentTime = getCurrentTime();</span><br><span class="line"></span><br><span class="line">if (typeof continuationCallback === &apos;function&apos;) &#123;</span><br><span class="line">    // 当前任务执行过程中被中断，则将之后需要继续执行的callback保存下来</span><br><span class="line">    currentTask.callback = continuationCallback;</span><br><span class="line">    markTaskYield(currentTask, currentTime);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    if (enableProfiling) &#123;</span><br><span class="line">        markTaskCompleted(currentTask, currentTime);</span><br><span class="line">        currentTask.isQueued = false;</span><br><span class="line">    &#125;</span><br><span class="line">    if (currentTask === peek(taskQueue)) &#123;</span><br><span class="line">        pop(taskQueue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>目前讲解了5个测试，而关于 scheduler 中的测试还有很多，更多的细节还需要自己去分析，希望本文可以起到抛砖引玉的作用，给你起了个阅读源码的头，勿急勿躁。下次会分享 schedulerBrowser-test，模拟浏览器环境对 scheduler 进行测试。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://avatars3.githubusercontent.com/u/16717283?s=460&v=4"
               alt="山石岩" />
          <p class="site-author-name" itemprop="name">山石岩</p>
           
              <p class="site-description motion-element" itemprop="description">大前端</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">21</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">山石岩</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"your-duoshuo-shortname"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  














  





  

  

  

  

  

  

</body>
</html>
